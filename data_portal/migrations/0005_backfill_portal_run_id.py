# Generated by Django 4.2.3 on 2023-09-05 07:59
from uuid import uuid4

from django.db import migrations


def __gen_backfill_portal_run_id(workflow):
    """
    backfill purpose only, pls do not use it outside of this module
    return in format e.g. 20230905BB1bcdef
    """
    return f"{workflow.start.strftime('%Y%m%d')}BB{str(uuid4())[:6]}"


def backfill_portal_run_id(apps, schema_editor):
    # We can't import the Workflow model directly as it may be a newer
    # version than this migration expects. We use the historical version.
    workflow = apps.get_model("data_portal", "Workflow")
    for wfl in workflow.objects.filter(portal_run_id__isnull=True):
        if wfl.portal_run_id is None:
            wfl.portal_run_id = __gen_backfill_portal_run_id(wfl)
            wfl.save()


class Migration(migrations.Migration):
    """
    This is data only migration. In contrast to schema migration.

    We will backfill all NULL value of `portal_run_id` from `Workflow` table with re-generated values.
    See https://umccr.slack.com/archives/CP356DDCH/p1693873519216669

    In Django, this kind of ops is called "data migration" script.
    https://docs.djangoproject.com/en/4.2/topics/migrations/#data-migrations
    https://docs.djangoproject.com/en/4.2/ref/migration-operations/#runpython

    Note that this is one-way data migration. Hence, noop for reverse.
    The `elidable` set to True so that in future when performing migration squash, this ops will be removed.
    """

    dependencies = [
        ('data_portal', '0004_delete_report'),
    ]

    operations = [
        migrations.RunPython(
            elidable=True,
            code=backfill_portal_run_id,
            reverse_code=migrations.RunPython.noop,
        )
    ]
